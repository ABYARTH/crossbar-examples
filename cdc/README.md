# Crossbar.io DevOps Center API

The public API is used by clients of **Crossbar.io DevOps Center (CDC)**. Calls to CDC may result in private API calls.

Since this API may be used by clients other than our own, it should be stable.

All calls are within the management realm to which the session issuing the calls is connected.


## Management Realms

A management realm is a realm on CDC dedicated to one larger system of a customer with potentially many thousand Crossbar.io nodes attached to and many thousand CDC API clients, like customer operators or tools.

Each management realm is fully isolated from all other management realms, serving different WAMP routing namespaces and with CDC backends running in dedicated processes, effectively preventing any data leakage.

## Authentication

Both Crossbar.io nodes and CDC API clients authenticate to CDC via WAMP-cryptosign.

WAMP-cryptosign is a public-private key authentication mechanism based on elliptic curve Curve25519, namely it adopts [Ed25519](http://ed25519.cr.yp.to/) to authenticate WAMP peers.

### User Authentication

For CDC API clients, the public-private keys are generated by the user with `ssh-keygen`, which is part of the standard OpenSSH package:

```console
ssh-keygen -t ed25519 -f mykey
```

> **Important: do NOT set a passphrase.** For simple use (like demonstrated here), keys should be protected using filesystem permissions, but otherwise not protected by a passphrase. To use a passphrase with your key, load and unlock your key into OpenSSH agent and use the agent support built into Autobahn for WAMP-cryptosign authentication.

Above will generate 2 files:

* `mykey` - the **private** user key (OpenSSH format)
* `mykey.pub` - the **public** user key (OpenSSH format)

Users are assigned one of the following authentication roles on the respective management realm upon successfull authentication:

* `cdc-guest`
* `cdc-devop`
* `cdc-admin`
* `cdc-owner`

### Node Authentication

For Crossbar.io nodes, the public-private keys are automatically generated when a node first starts:

* `CBDIR/.crossbar/key.priv` - the **private** node key (Crossbar.io format)
* `CBDIR/.crossbar/key.pub` - the **public** node key (Crossbar.io format)

Crossbar.io nodes need to be **paired** with CDC first. The node pairing makes the node's public key known to CDC, associates the node with a **management realm** and assign a node ID to the node.

> The node ID is identical to the WAMP `authid` assigned by CDC during the authentication to the Crossbar.io node.

All Crossbar.io nodes are assigned the authentication role

* `cdc-node`

on the respective management realm after successfull authentication.

### CDC Pairing

#### Manual

During the alpha-testing of the first CDC ready Crossbar.io release 16.10, pairing of Crossbar.io nodes and CDC API clients with CDC is not yet available and provisioning of new management realms and users involves some manual steps beginning with sending us

* your desired **management realm name**,
* the **owner's user public key** (OpenSSH format) and
* optionally, one or more **Crossbar.io node public keys** (Crossbar.io format) and
* optionally, one or more **CDC API client public keys** (OpenSSH format)

Drop us an email at **`support at crossbario dot com`** with subject line **`alpha-16.10`** and we'll setup your management realm on our CDC alpha hosting service and provide you access from Web UIs, command line tools or programmatic and remote access to your Crossbar.io nodes.

#### API based

With API based pairing, the owner of a management realm will be able to call CDC procedures which add, provision and configure Crossbar.io node public keys and CDC API client public keys allowed access to that management realm.

The management realm owner's key pair should be protected well, and only used to create day to day key pairs for administrators of the management realm itself.

The API (preliminary) may look like

```
com.crossbario.cdc.register_user@1(<user_name|string>, <user_email|string>, <user_pub_key|string>) -> <registration_id|int>
```

to initiate registration of a new user providing a user name, email and first public key. The user name is checked that is does not yet exist and meets the requirements for user names. When these conditions are met, a challenge in form of a graphical captcha with an embedded, five digit numeric PIN is sent via email to the email address provided.

The user will need to read the PIN from the captcha and enter that allowing to make the call to

```
com.crossbario.cdc.verify_user_registration(<registration_id|int>, <pin|int>) -> <OK>
```

When this call returns successfully, the user is created.

To register more public keys for the user, calls abovr procedure again. This will send a challenge as well and proceed exactly like above.

To register a new management realm, a similar API is available:

```
com.crossbario.cdc.register_management_realm(<management_realm|string>, <owner_pub_key|string>) -> <registration_id|int>
```

to initiate registration of a new management realm providing the management realm name and owner's public key,

The public key must have been registered before for a user,

The registering owner's email address is already known, and used for sending a captcha with a PIN like above to the owner. Verification is similar:

```
com.crossbario.cdc.verify_management_realm_registration(<registration_id|int>, <pin|int>) -> <OK>
```

When this call returns successfully, the management realm is created.

The owner of the management realm can manage the realm by allowing new Crossbar.io node public keys and CDC API client public keys access to the management realm under respective roles.


### Displaying keys

The Crossbar.io release key (which changes with each release) is displayed together with version information

```console
(cpy351_5) oberstet@thinkpad-t430s:~$ crossbar version
     __  __  __  __  __  __      __     __
    /  `|__)/  \/__`/__`|__) /\ |__)  |/  \
    \__,|  \\__/.__/.__/|__)/~~\|  \. |\__/

 Crossbar.io        : 16.10.dev1
   Autobahn         : 0.16.0 (with JSON, MessagePack, CBOR, UBJSON)
   Twisted          : 16.3.0-EPollReactor
   LMDB             : 0.89/lmdb-0.9.18
   Python           : 3.5.1/CPython
 OS                 : Linux-3.13.0-92-generic-x86_64-with-debian-jessie-sid
 Machine            : x86_64
 Release key        : RWQ2MDk26PKBMNUZG2Jok1tMBB1SKyci+N7dtcep8jrikTl4NvI1Rnux
```

The node public key is printed when the node starts:

```console
(cpy351_5) oberstet@thinkpad-t430s:~/foo$ crossbar start
2016-08-14T22:25:45+0200 [Controller  20410] New node key pair generated!
2016-08-14T22:25:45+0200 [Controller  20410] File permissions on node public key fixed!
2016-08-14T22:25:45+0200 [Controller  20410] File permissions on node private key fixed!
2016-08-14T22:25:45+0200 [Controller  20410] Node configuration loaded from 'config.json'
2016-08-14T22:25:45+0200 [Controller  20410]      __  __  __  __  __  __      __     __
2016-08-14T22:25:45+0200 [Controller  20410]     /  `|__)/  \/__`/__`|__) /\ |__)  |/  \
2016-08-14T22:25:45+0200 [Controller  20410]     \__,|  \\__/.__/.__/|__)/~~\|  \. |\__/
2016-08-14T22:25:45+0200 [Controller  20410]
2016-08-14T22:25:45+0200 [Controller  20410]     Crossbar.io Version: 16.10.dev1
2016-08-14T22:25:45+0200 [Controller  20410]     Node Public Key: 0a439d8ec8a36c2a7ecd4388ed6f0221fa6e2e46a8e6c8481ab7950a4dc27735
2016-08-14T22:25:45+0200 [Controller  20410]
2016-08-14T22:25:45+0200 [Controller  20410] Running from node directory '/home/oberstet/foo/.crossbar'
```


## Tutorial

### Connect to CDC

Connecting to CDC and retrieving the management realm status:

```python
from twisted.internet.defer import inlineCallbacks
import util

@inlineCallbacks
def main(session, details):
    try:
        status = yield session.call(u'com.crossbario.cdc.general.get_status@1')
    except:
        session.log.failure()
    else:
        session.log.info('Connected to CDC management realm "{realm}" (current time at CDC is {now})',
                         realm=status[u'realm'], now=status[u'now'])

util.run(main)
```

Here is a sample run:

```console
(cpy352_2) oberstet@office-corei7:~/scm/crossbario/crossbarexamples/cdc$ python tut1.py
2016-08-13T16:16:48+0200 Connected to CDC management realm "com.crossbario.cdc.mrealm-test1" (current time at CDC is 2016-08-13T14:16:48.414Z)
2016-08-13T16:16:48+0200 Main loop terminated.
```

### Get Crossbar.io nodes

Connecting to CDC, getting a list of Crossbar.io nodes provisioned on that realm and retrieving the current status of each node:

```python
from twisted.internet.defer import inlineCallbacks
import util

@inlineCallbacks
def main(session, details):
    try:
        nodes = yield session.call(u'com.crossbario.cdc.management.get_nodes@1')
    except:
        session.log.failure()
    else:
        session.log.info('Nodes on management realm "{realm}"', realm=details.realm)
        for node_id in nodes:
            node_status = yield session.call(u'com.crossbario.cdc.management.get_node_status@1', node_id)
            session.log.info('Node "{node_id}": {node_status}', node_id=node_id, node_status=node_status)

util.run(main)
```

Here is a sample run:

```console
(cpy352_2) oberstet@office-corei7:~/scm/crossbario/crossbarexamples/cdc$ python tut2.py
2016-08-13T16:17:52+0200 Nodes on management realm "com.crossbario.cdc.mrealm-test1"
2016-08-13T16:17:52+0200 Node "node0": {'node_id': 'node0', 'extra': {'foo': 42, 'bar': 'baz'}, 'status': 'created'}
2016-08-13T16:17:52+0200 Node "node1": {'node_id': 'node1', 'extra': {'foo': 23, 'bar': 'moo'}, 'status': 'running'}
2016-08-13T16:17:52+0200 Main loop terminated.
```

## API Reference

### API Versioning

* `com.crossbario.cdc.some_proc@1()`
* `com.crossbario.cdc.some_proc@2(<filter_status|string>) -> [<node_info|dict>]` where `node_info` is a struct describing a node
* `com.crossbario.cdc.some_proc@3(<filter_type|string>, <filter_status|string>) -> {<node_id>: <node_info>}` where `node_id` is the ID of a node and `node_info` is a struct describing the node


### Global API

* `com.crossbario.cdc.get_status@1()` - returns management status information.
* `com.crossbario.cdc.get_nodes@1()` - returns a list of ID of Crossbar.io nodes attached to this management realm
* `com.crossbario.cdc.get_node_status@1(<node_id|string>) -> { // node info dict // }`

### Remote Node API

* `com.crossbario.cdc.remote.get_controller_status@1(<node_id|string>) -> { // controller info dict // }`

* `com.crossbario.cdc.remote.shutdown_node@1()`
* `com.crossbario.cdc.remote.get_node_workers@1(<node_id|string>)`
* `com.crossbario.cdc.remote.get_worker_status@1(<node_id|string>, <worker_id|string>) -> { // worker info dict // }`
* `com.crossbario.cdc.remote.get_worker_log@1(<node_id|string>, <worker_id|string>) -> [ // log line dicts // ]`
* `com.crossbario.cdc.remote.start_router_worker@1(<node_id|string>, <router_id|string>, <router_config|dict>) -> <started_at|string>`
* `com.crossbario.cdc.remote.start_container_worker@1(<node_id|string>, <container_id|string>, <container_config|dict>) -> <started_at|string>`
* `com.crossbario.cdc.remote.start_guest_worker@1(<node_id|string>, <guest_id|string>, <guest_config|dict>) -> <started_at|string>`

#### (Native) Workers

* `com.crossbario.cdc.remote.shutdown_worker@1`
* `com.crossbario.cdc.remote.get_worker_cpu_count@1`
* `com.crossbario.cdc.remote.get_worker_cpu_affinity@1`
* `com.crossbario.cdc.remote.set_worker_cpu_affinity@1(<node_id|string>, <worker_id|string>, [<cpu_no|int]) -> void`
* `com.crossbario.cdc.remote.get_worker_pythonpath@1(<node_id|string>, <worker_id|string>) -> []`
* `com.crossbario.cdc.remote.add_worker_pythonpath@1()`
* `com.crossbario.cdc.remote.get_worker_profilers@1`
* `com.crossbario.cdc.remote.start_worker_profiler@1`
* `com.crossbario.cdc.remote.get_worker_profile@1`

#### Routers

##### Global

##### Router Realms

* `com.crossbario.cdc.remote.get_router_realms@1`
* `com.crossbario.cdc.remote.get_router_realm_status@1`
* `com.crossbario.cdc.remote.start_router_realm@1`
* `com.crossbario.cdc.remote.stop_router_realm@1`

##### Realm Roles

* `com.crossbario.cdc.remote.get_realm_roles@1`
* `com.crossbario.cdc.remote.get_realm_role_status@1`
* `com.crossbario.cdc.remote.start_realm_role@1`
* `com.crossbario.cdc.remote.stop_realm_role@1`

##### Router Transports

* `com.crossbario.cdc.remote.get_router_transports@1`
* `com.crossbario.cdc.remote.get_router_transport_status@1`
* `com.crossbario.cdc.remote.start_router_transport@1`
* `com.crossbario.cdc.remote.stop_router_transport@1`

##### Web Transport Services

* `com.crossbario.cdc.remote.get_web_services@1`
* `com.crossbario.cdc.remote.get_web_service_status@1`
* `com.crossbario.cdc.remote.start_web_service@1`
* `com.crossbario.cdc.remote.stop_web_service@1`

##### Router Components

* `com.crossbario.cdc.remote.get_router_components@1`
* `com.crossbario.cdc.remote.get_router_component_status@1`
* `com.crossbario.cdc.remote.start_router_component@1`
* `com.crossbario.cdc.remote.stop_router_component@1`

#### Containers

##### Global

* `com.crossbario.cdc.remote.stop_container@1`

##### Container Components

* `com.crossbario.cdc.remote.get_container_components@1`
* `com.crossbario.cdc.remote.get_container_component_status@1`
* `com.crossbario.cdc.remote.start_container_component@1`
* `com.crossbario.cdc.remote.stop_container_component@1`
* `com.crossbario.cdc.remote.restart_container_component@1`


### List Workers

* **Procedure** `io.crossbar.cdc.list_workers`

List all workers created for the given node.

Arguments:

   * `node_id` - *string* - the ID of the node to list the workers for (*required*)


### Create Node

* **Procedure** `io.crossbar.cdc.create_node`

Create a new node.

Arguments:

   * `node_id` - *string* - an ID for the node to be created (*required*)
   * `node_config` - *dictionary* - the node configuration (*required*)


### List Node Workers

* **Procedure** `io.crossbar.cdc.list_node_workers`

List all workers created on the given node.

Arguments:

   * `node_id`- *string* - the id of the node for which to list workers (*required*)

## Router-related

* `get_router`
* `create_router`
* `modify_router`
* `delete_router`
* `start_router`
* `stop_router`
* `reload_router`


### Get Router

* **Procedure** `io.crossbar.cdc.get_router`

Get configuration and status of existing router.

Arguments:

   * `node_id` - *string* - the id of the node which hosts the router (*required*)
   * `router_id` - *string* - the id of the router (*required*)


### Create Router

* **Procedure** `io.crossbar.cdc.create_router`

Create a router on a node.

> Note: This directly only creates a database entry with the set configuration. To actually start the router, the start router procedure needs to be called.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is to be created (*required*)
   * `router_id` - *string* - an ID for the router to be created (*required*)
   * `router_config` - *dictionary* - the configuration for the router (*required*)


### Modify Router

* **Procedure** `io.crossbar.cdc.modify_router`

Modify a router worker configuration on a given node.

> Note: This directly only changes the database entry. To actually apply changes to a running router worker, the worker needs to be reloaded or restarted.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be modified (*required*)
   * `router_config` - *dictionary* - the configuration change set for the router (*required*)


### Delete Router

* **Procedure** `io.crossbar.cdc.delete_router`

Delete a router worker configuration on a given node. A router worker configuration can only be deleted when the respective router worker is currently stopped!

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be deleted (*required*)


### Start Router

* **Procedure** `io.crossbar.cdc.start_router`

Start a previously created router. The router worker will be started with the currently active configuration.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be started (*required*)


### Stop Router

* **Procedure** `io.crossbar.cdc.stop_router`

Stop a running router worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be stopped (*required*)


### Reload Router

* **Procedure** `io.crossbar.cdc.reload_router`

Reload the configuration of a currently running router worker. When a router configuration has changed, the changes will only be applied once this procedure is called (or the router is restarted).

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be reloaded (*required*)
   * `restart_if_required' - *boolean* - Restart the router if one or more configuration changes cannot be applied without a restart. An exception is raised if this is `false` and a restart would be required in order to apply all changes. (*optional*)


## Worker-related

* `profile_worker`
* `get_stats`

### Profile Worker

Get a profile of the processor usage within a worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the worker is hosted (*required*)
   * `worker_id` - *string* - the id of the worker on which to run the profile (*required*)
   * `profiler` - *string* - the profiler to start (currently only 'vmprof' is supported - (*optional* - default: `vmprof`)
   * `runtime` - *integer* - the duration in seconds for which to enable profiling and generate a profile (*optional* - default: 10)
   * `profiler` - *integer* - prune % (*optional* - default: 5)
   * `profiler` - *integer* - prune level (*optional* - default: 1000)

### Get Stats

Get the generic worker statistics (e.g. cpu affinity, uptime) for a specific worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the worker is hosted (*required*)
   * `worker_id` - *string* - the id of the worker for which to receive the stats (*required*)
