# Crossbar.io DevOps Center API

The public API is used by clients of **Crossbar.io DevOps Center (CDC)**. Calls to CDC may result in private API calls.

Since this API may be used by clients other than our own, it should be stable.

All calls are within the management realm to which the session issuing the calls is connected.


## Management Realms

A management realm is a realm on CDC dedicated to one larger system of a customer with potentially many thousand Crossbar.io nodes attached to and many thousand CDC API clients, like customer operators or tools.

Each management realm is fully isolated from all other management realms, serving different WAMP routing namespaces and with CDC backends running in dedicated processes, effectively preventing any data leakage.

## Authentication

Both Crossbar.io nodes and CDC API clients authenticate to CDC via WAMP-cryptosign.

WAMP-cryptosign is a public-private key authentication mechanism based on elliptic curve Curve25519, namely it adopts [Ed25519](http://ed25519.cr.yp.to/) to authenticate WAMP peers.

### User Authentication

For CDC API clients, the public-private keys are generated by the user with `ssh-keygen`, which is part of the standard OpenSSH package:

```console
ssh-keygen -t ed25519 -f oberstet
```

> **Important: do NOT set a passphrase.** For simple use (like demonstrated here), keys should be protected using filesystem permissions, but otherwise not protected by a passphrase. To use a passphrase with your key, load and unlock your key into OpenSSH agent and use the agent support built into Autobahn for WAMP-cryptosign authentication.

Above will generate 2 files:

* `oberstet` - the **private** user key (OpenSSH format)
* `oberstet.pub` - the **public** user key (OpenSSH format)

Users are assigned one of the following authentication roles on the respective management realm upon successfull authentication:

* `cdc-guest`
* `cdc-devop`
* `cdc-admin`
* `cdc-owner`

### Node Authentication

For Crossbar.io nodes, the public-private keys are automatically generated when a node first starts:

* `CBDIR/.crossbar/key.priv` - the **private** node key (Crossbar.io format)
* `CBDIR/.crossbar/key.pub` - the **public** node key (Crossbar.io format)

Crossbar.io nodes need to be **paired** with CDC first. The node pairing makes the node's public key known to CDC, associates the node with a **management realm** and assign a node ID to the node.

> The node ID is identical to the WAMP `authid` assigned by CDC during the authentication to the Crossbar.io node.

All Crossbar.io nodes are assigned the authentication role

* `cdc-node`

on the respective management realm after successfull authentication.

### CDC Pairing

#### Manual

During the alpha-testing of the first CDC ready Crossbar.io release 16.10, pairing of Crossbar.io nodes and CDC API clients with CDC is not yet available and provisioning of new management realms and users involves some manual steps beginning with sending us

* your desired **management realm name**,
* the **owner's user public key** (OpenSSH format) and
* optionally, one or more **Crossbar.io node public keys** (Crossbar.io format) and
* optionally, one or more **CDC API client public keys** (OpenSSH format)

Drop us an email at **`support at crossbario dot com`** with subject line **`alpha-16.10`** and we'll setup your management realm on our CDC alpha hosting service and provide you access from Web UIs, command line tools or programmatic and remote access to your Crossbar.io nodes.

#### API based

With API based pairing, the owner of a management realm will be able to call CDC procedures which add, provision and configure Crossbar.io node public keys and CDC API client public keys allowed access to that management realm.

The management realm owner's key pair should be protected well, and only used to create day to day key pairs for administrators of the management realm itself.

The API (preliminary) may look like

```
crossbario.cdc.register_user(user_name, user_email, user_pub_key) -> registration_id
```

to initiate registration of a new user providing a user name, email and first public key. The user name is checked that is does not yet exist and meets the requirements for user names. When these conditions are met, a challenge in form of a graphical captcha with an embedded, five digit numeric PIN is sent via email to the email address provided.

The user will need to read the PIN from the captcha and enter that allowing to make the call to

```
crossbario.cdc.verify_user_registration(registration_id, pin) -> OK
```

When this call returns successfully, the user is created.

To register more public keys for the user, call

```
crossbario.cdc.register_user(user_name, user_email, user_pub_key) -> registration_id
```

This will send a challenge as well and proceed exactly like above.

To register a new management realm, a similar API is available:

```
cdc.register_management_realm(management_realm, owner_pub_key) -> registration_id
```

to initiate registration of a new management realm providing the management realm name and owner's public key,

The public key must have been registered before for a user,

The registering owner's email address is already known, and used for sending a captcha with a PIN like above to the owner. Verification is similar:

```
crossbario.cdc.verify_management_realm_registration(registration_id, pin) -> OK
```

When this call returns successfully, the management realm is created.

The owner of the management realm can manage the realm by allowing new Crossbar.io node public keys and CDC API client public keys access to the management realm under respective roles.


## Full list

### Global

* `crossbario.cdc.get_now@1()`
* `crossbario.cdc.get_nodes@1(<filter-status>)`
* `crossbario.cdc.get_nodes@2(<filter-type>, <filter-status>)`

### Nodes

* `crossbario.cdc.get_node_info@1`
* `crossbario.cdc.get_controller_info@1`
* `crossbario.cdc.get_controller_stats@1`
* `crossbario.cdc.shutdown_node@1`
* `crossbario.cdc.get_node_workers@1`
* `crossbario.cdc.get_worker_log@1`
* `crossbario.cdc.start_router_worker@1`
* `crossbario.cdc.start_container_worker@1`
* `crossbario.cdc.start_guest_worker@1`

### (Native) Workers

* `crossbario.cdc.shutdown_worker`
* `crossbario.cdc.get_worker_cpu_count`
* `crossbario.cdc.get_worker_cpu_affinity`
* `crossbario.cdc.set_worker_cpu_affinity`
* `crossbario.cdc.get_worker_pythonpath`
* `crossbario.cdc.add_worker_pythonpath`
* `crossbario.cdc.get_worker_profilers`
* `crossbario.cdc.start_worker_profiler`
* `crossbario.cdc.get_worker_profile`

### Routers

#### Global

#### Router Realms

* `crossbario.cdc.get_router_realms`
* `crossbario.cdc.get_router_realm_status`
* `crossbario.cdc.start_router_realm`
* `crossbario.cdc.stop_router_realm`

#### Realm Roles

* `crossbario.cdc.get_realm_roles`
* `crossbario.cdc.get_realm_role_status`
* `crossbario.cdc.start_realm_role`
* `crossbario.cdc.stop_realm_role`

#### Router Transports

* `crossbario.cdc.get_router_transports`
* `crossbario.cdc.get_router_transport_status`
* `crossbario.cdc.start_router_transport`
* `crossbario.cdc.stop_router_transport`

#### Web Transport Services

* `crossbario.cdc.get_web_services`
* `crossbario.cdc.get_web_service_status`
* `crossbario.cdc.start_web_service`
* `crossbario.cdc.stop_web_service`

#### Router Components

* `crossbario.cdc.get_router_components`
* `crossbario.cdc.get_router_component_status`
* `crossbario.cdc.start_router_component`
* `crossbario.cdc.stop_router_component`

### Containers

#### Global

* `crossbario.cdc.stop_container`

#### Container Components

* `crossbario.cdc.get_container_components`
* `crossbario.cdc.get_container_component_status`
* `crossbario.cdc.start_container_component`
* `crossbario.cdc.stop_container_component`

* `crossbario.cdc.restart_container_component`


## CDC-related

### Get Time

* **Procedure** `crossbario.cdc.get_now`

Get the current time (as UTC) of the CDC. (Implemented mostly to check whether contact to the CDC is working.)

## Node-related

### List Nodes

* **Procedure** `crossbario.cdc.get_nodes`

List all Crossbar.io nodes on the management realm connected to.


### List Workers

* **Procedure** `io.crossbar.cdc.list_workers`

List all workers created for the given node.

Arguments:

   * `node_id` - *string* - the ID of the node to list the workers for (*required*)


### Create Node

* **Procedure** `io.crossbar.cdc.create_node`

Create a new node.

Arguments:

   * `node_id` - *string* - an ID for the node to be created (*required*)
   * `node_config` - *dictionary* - the node configuration (*required*)


### List Node Workers

* **Procedure** `io.crossbar.cdc.list_node_workers`

List all workers created on the given node.

Arguments:

   * `node_id`- *string* - the id of the node for which to list workers (*required*)

## Router-related

* `get_router`
* `create_router`
* `modify_router`
* `delete_router`
* `start_router`
* `stop_router`
* `reload_router`


### Get Router

* **Procedure** `io.crossbar.cdc.get_router`

Get configuration and status of existing router.

Arguments:

   * `node_id` - *string* - the id of the node which hosts the router (*required*)
   * `router_id` - *string* - the id of the router (*required*)


### Create Router

* **Procedure** `io.crossbar.cdc.create_router`

Create a router on a node.

> Note: This directly only creates a database entry with the set configuration. To actually start the router, the start router procedure needs to be called.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is to be created (*required*)
   * `router_id` - *string* - an ID for the router to be created (*required*)
   * `router_config` - *dictionary* - the configuration for the router (*required*)


### Modify Router

* **Procedure** `io.crossbar.cdc.modify_router`

Modify a router worker configuration on a given node.

> Note: This directly only changes the database entry. To actually apply changes to a running router worker, the worker needs to be reloaded or restarted.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be modified (*required*)
   * `router_config` - *dictionary* - the configuration change set for the router (*required*)


### Delete Router

* **Procedure** `io.crossbar.cdc.delete_router`

Delete a router worker configuration on a given node. A router worker configuration can only be deleted when the respective router worker is currently stopped!

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be deleted (*required*)


### Start Router

* **Procedure** `io.crossbar.cdc.start_router`

Start a previously created router. The router worker will be started with the currently active configuration.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be started (*required*)


### Stop Router

* **Procedure** `io.crossbar.cdc.stop_router`

Stop a running router worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be stopped (*required*)


### Reload Router

* **Procedure** `io.crossbar.cdc.reload_router`

Reload the configuration of a currently running router worker. When a router configuration has changed, the changes will only be applied once this procedure is called (or the router is restarted).

Arguments:

   * `node_id` - *string* - the id of the node on which the router is hosted (*required*)
   * `router_id` - *string* - the id of the router to be reloaded (*required*)
   * `restart_if_required' - *boolean* - Restart the router if one or more configuration changes cannot be applied without a restart. An exception is raised if this is `false` and a restart would be required in order to apply all changes. (*optional*)


## Worker-related

* `profile_worker`
* `get_stats`

### Profile Worker

Get a profile of the processor usage within a worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the worker is hosted (*required*)
   * `worker_id` - *string* - the id of the worker on which to run the profile (*required*)
   * `profiler` - *string* - the profiler to start (currently only 'vmprof' is supported - (*optional* - default: `vmprof`)
   * `runtime` - *integer* - the duration in seconds for which to enable profiling and generate a profile (*optional* - default: 10)
   * `profiler` - *integer* - prune % (*optional* - default: 5)
   * `profiler` - *integer* - prune level (*optional* - default: 1000)

### Get Stats

Get the generic worker statistics (e.g. cpu affinity, uptime) for a specific worker.

Arguments:

   * `node_id` - *string* - the id of the node on which the worker is hosted (*required*)
   * `worker_id` - *string* - the id of the worker for which to receive the stats (*required*)
